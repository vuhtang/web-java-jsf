import javax.sound.sampled.*
import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Files
import java.nio.file.Paths
import java.security.MessageDigest

plugins {
    id 'java'
    id 'war'
    id 'org.hidetake.ssh' version '2.11.2'
}

group 'com.vuhtang'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

ext {
    junitVersion = '5.9.2'
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

dependencies {
    compileOnly('jakarta.platform:jakarta.jakartaee-api:9.1.0')
    implementation group: 'com.google.code.gson', name: 'gson', version: '2.9.1'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'

    implementation group: 'javax.validation', name: 'validation-api', version: '2.0.1.Final'
    implementation group: 'javax.persistence', name: 'javax.persistence-api', version: '2.2'

    implementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.28'
    implementation group: 'com.google.protobuf', name: 'protobuf-java', version: '3.21.7'
    implementation group: 'org.hibernate', name: 'hibernate-core', version: '5.6.10.Final'

}

test {
    useJUnitPlatform()
}

//Компиляция
tasks.register("compileProject", JavaCompile) {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_DIR
    destinationDirectory = file(BIN_DIR)
}

//Сборка джарника
tasks.register("buildProject", Jar) {
    dependsOn compileProject
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Чистка билда
tasks.register("cleanProject", Delete) {
    delete 'build'
}

tasks.register('JUnitTests', Test) {
    useJUnitPlatform()
    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

Map<String, String> getMainAttr() {
    Map<String, String> attr = new HashMap<>()
    attr.put("Main-Class", MAIN_CLASS)
    return attr
}

static Map<String, String> getHashAttributes() {
    Map<String, String> attr = new HashMap<>()
    List<String> projectFiles = listFilesFromDir('src')
    String checkSumMD5 = hashFilesWithAlgorithm("MD5", projectFiles)
    String checkSumSHA1 = hashFilesWithAlgorithm("SHA-1", projectFiles)
    attr.put("MD5", checkSumMD5)
    attr.put("SHA-1", checkSumSHA1)
    return attr
}

static List<String> listFilesFromDir(String dir) {
    List<String> list = new ArrayList<>()
    for (File f : new File(dir).listFiles()) {
        if (f.isDirectory())
            list.addAll(listFilesFromDir(f.toString()))
        else
            list.add(f.toString())
    }
    return list
}

static String hashFilesWithAlgorithm(String algorithm, List<String> files) {
    MessageDigest md = MessageDigest.getInstance(algorithm)
    for (String f : files) {
        md.update(Files.readAllBytes(Paths.get(f)))
    }
    String checkSum = Base64.getEncoder().encodeToString(md.digest())
    return checkSum
}

tasks.register('docc', Jar) {
    dependsOn javadoc
    Map<String, String> mainAttrs = getMainAttr()
    Map<String, String> hashes = getHashAttributes()
    manifest {
        attributes(mainAttrs)
        attributes(hashes, "Hashes")
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    from(JAVADOC_DIR) {
        include 'javadoc/'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Музыкальная сборка джарника
tasks.register("music") {
    dependsOn buildProject
    doLast {
        def musicFile = new File(MUSIC_FILE)
        AudioInputStream audioStream = AudioSystem.getAudioInputStream(musicFile)
        Clip clip = AudioSystem.getClip()
        clip.open(audioStream)
        clip.start()
    }
}

//проверяет валидность всех xml проекта
tasks.register("xml") {
    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        fileTree(dir: 'src', include: '**/*.xml').each { file ->
            try {
                parser.parse(file)
                println "File $file is valid."
            } catch (Exception e) {
                println "File $file is not valid: ${e.message}"
            }
        }
    }
}

tasks.register('native2ascii') {
    doLast {
        ant.native2ascii(
                src: 'src/main/resources',
                includes: '**.properties',
                dest: 'src/main/resources/ASCII')
    }
}

List<String> readFilesResistantForDiff() {
    List<String> files = new ArrayList<>()
    try {
        BufferedReader reader = new BufferedReader(new FileReader(new File(DIFF_FILE)))
        files = reader.readLines()
    } catch (FileNotFoundException e) {
        e.printStackTrace()
    } catch (IOException e) {
        e.printStackTrace()
    }
    return files
}

tasks.register('gitdiff') {
    doLast {
        List<String> filesFromProperties = readFilesResistantForDiff()
        String changedFile = ""
        boolean wrongFileWasModified = false
        def out = new ByteArrayOutputStream()
        for (String file : filesFromProperties) {

            exec {
                commandLine 'git', 'diff', file
                standardOutput = out
            }

            if (out.size() > 0) {
                changedFile = file
                wrongFileWasModified = true
                break
            }
        }
        out.close()

        if (wrongFileWasModified) {
            println("File \"" + changedFile + "\" from properties has been modified")
            println("Commit rejected")
        } else {
            exec {
                commandLine 'git', 'add', '.'
            }
            exec {
                commandLine 'git', 'commit', '-m', '"commit with gitdiff task"'
            }
        }
    }
}

remotes {
    web01 {
        host = 'se.ifmo.ru'
        user = 's336428'
        port = 2222
        password = PASSWORD
    }
}

tasks.register('scp') {
    dependsOn buildProject

    String pathToJar = LIB_DIR + "/" + JAR_NAME

    doLast {
        ssh.run {
            settings {
                pty = true
            }
            session(remotes.web01) {
                put from: file(pathToJar), into: PATH_TO_REMOTE_DIR
            }
        }
    }
}

tasks.register('preAlt') {
    doLast {
        ant.replaceregexp(
                file: PATH_TO_CFG,
                match: "execTime",
                replace: "executionTime",
                flags: "g"
        )
    }
}

compileProject.shouldRunAfter(preAlt)

tasks.register('buildAlt', Jar) {
    dependsOn preAlt, compileProject
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_NAME_ALT
    destinationDirectory = file(LIB_DIR)
}

tasks.register('alt') {
    dependsOn buildAlt
    doLast {
        ant.replaceregexp(
            file: PATH_TO_CFG,
            match: "executionTime",
            replace: "execTime",
            flags: "g"
        )
    }
}

tasks.register('svnCheckout') {
    ByteArrayOutputStream out = new ByteArrayOutputStream()
    doLast {
        exec {
            commandLine 'svn', 'checkout', SVN_REPO, 'tmp'
            standardOutput = new ByteArrayOutputStream()
        }

        File tmp = new File('tmp')
        svnCheckout.extensions.tmp = tmp
        exec {
            workingDir(tmp)
            commandLine 'svn', 'info', '--show-item', 'revision'
            standardOutput = out
        }
        int lastRevisionNumber = Integer.parseInt(out.toString().strip())
        svnCheckout.extensions.lastRevisionNumber = lastRevisionNumber
        out.close()
    }
}

tasks.register('compileSvn1', JavaCompile) {
    dependsOn svnCheckout
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_SVN_DIR
    destinationDirectory = file(BIN_SVN_DIR)
}

tasks.register('buildSvn1', Jar) {
    dependsOn compileSvn1
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_SVN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_SVN_NAME
    destinationDirectory = file(LIB_DIR)
}

tasks.register('svnCheckout2') {
    dependsOn buildSvn1
    doLast {
        exec {
            workingDir(svnCheckout.extensions.tmp)
            commandLine 'svn', 'up', '-r', svnCheckout.extensions.lastRevisionNumber - 1
        }
        buildSvn1.archiveFileName = JAR_SVN_NAME1
    }
}

tasks.register('compileSvn2', JavaCompile) {
    dependsOn svnCheckout2
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_SVN_DIR
    destinationDirectory = file(BIN_SVN_DIR)
}

tasks.register('buildSvn2', Jar) {
    dependsOn compileSvn2
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_SVN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_SVN_NAME1
    destinationDirectory = file(LIB_DIR)
}

tasks.register('svnCheckout3') {
    dependsOn buildSvn2
    doLast {
        exec {
            workingDir(svnCheckout.extensions.tmp)
            commandLine 'svn', 'up', '-r', svnCheckout.extensions.lastRevisionNumber - 2
        }
        buildSvn1.archiveFileName = JAR_SVN_NAME1
    }
}

tasks.register('compileSvn3', JavaCompile) {
    dependsOn svnCheckout3
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_SVN_DIR
    destinationDirectory = file(BIN_SVN_DIR)
}

tasks.register('buildSvn3', Jar) {
    dependsOn compileSvn3
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_SVN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_SVN_NAME2
    destinationDirectory = file(LIB_DIR)
}

tasks.register('zipSvn', Zip) {
    dependsOn buildSvn3
    from(LIB_DIR) {
        include '**/*.jar'
    }
    archiveFileName = ZIP_SVN_NAME
    destinationDirectory = file(LIB_DIR)
}

tasks.register('del', Delete) {
    dependsOn zipSvn
    delete 'tmp', LIB_DIR + "/" + JAR_SVN_NAME, LIB_DIR + "/" + JAR_SVN_NAME1, LIB_DIR + "/" + JAR_SVN_NAME2
}
tasks.register('team') {
    dependsOn del
}

tasks.register('history') {
    doLast {
        OutputStream out = new ByteArrayOutputStream()
        FileOutputStream fOut = new FileOutputStream("sources.txt")
        exec {
            commandLine 'find', 'src/main', '-name', '*.java'
            standardOutput out
        }
        out.writeTo(fOut)
        out.close()
        fOut.close()
        int v = exec {
            commandLine 'javac', '-d', BIN_DIR, '@sources.txt'
            standardOutput = new ByteArrayOutputStream()
            errorOutput = standardOutput
            ignoreExitValue true
        }.getExitValue()
        delete 'sources.txt'
        if (v != 0) {
            // svnCheckout
            OutputStream out1 = new ByteArrayOutputStream()
            OutputStream out2 = new ByteArrayOutputStream()
            exec {
                commandLine 'svn', 'checkout', SVN_REPO, 'tmp'
                standardOutput = out2
            }
            out2.close()

            File tmp = new File('tmp')
            exec {
                workingDir(tmp)
                commandLine 'svn', 'info', '--show-item', 'revision'
                standardOutput = out1
            }
            int lastRevisionNumber = Integer.parseInt(out1.toString().strip())
            out1.close()
            //

            int cur = lastRevisionNumber
            while (v != 0 && cur > 1) {
                cur -= 1
                exec {
                    workingDir(tmp)
                    commandLine 'svn', 'up', '-r', cur
                }
                out = new ByteArrayOutputStream()
                fOut = new FileOutputStream("sources.txt")
                exec {
                    commandLine 'find', 'tmp/jsf/src/main', '-name', '*.java'
                    standardOutput = out
                }
                out.writeTo(fOut)
                out.close()
                fOut.close()
                v = exec {
                    commandLine 'javac', '-d', BIN_DIR, '@sources.txt'
                    ignoreExitValue true
                    standardOutput = new ByteArrayOutputStream()
                    errorOutput = standardOutput
                }.getExitValue()
                delete 'sources.txt'
            }
            OutputStream out3 = new ByteArrayOutputStream()
            OutputStream fOut3 = new FileOutputStream("gradle/report.txt")
            String s = cur + ':' + (lastRevisionNumber-1)
            exec {
                workingDir(tmp)
                commandLine 'svn', 'diff', '-r', s
                standardOutput = out3
            }
            out3.writeTo(fOut3)
            out3.flush()
            out3.close()
            fOut3.close()
            delete 'tmp'
        }
    }
}

