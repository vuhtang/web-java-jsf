import javax.sound.sampled.*
import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Files
import java.nio.file.Paths
import java.security.MessageDigest

plugins {
    id 'java'
    id 'war'
    id 'org.hidetake.ssh' version '2.11.2'
}

group 'com.vuhtang'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

ext {
    junitVersion = '5.9.2'
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

dependencies {
    compileOnly('jakarta.platform:jakarta.jakartaee-api:9.1.0')
    implementation group: 'com.google.code.gson', name: 'gson', version: '2.9.1'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'

    implementation group: 'javax.validation', name: 'validation-api', version: '2.0.1.Final'
    implementation group: 'javax.persistence', name: 'javax.persistence-api', version: '2.2'

    implementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.28'
    implementation group: 'com.google.protobuf', name: 'protobuf-java', version: '3.21.7'
    implementation group: 'org.hibernate', name: 'hibernate-core', version: '5.6.10.Final'

}

test {
    useJUnitPlatform()
}

//Компиляция
tasks.register("compileProject", JavaCompile) {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_DIR
    destinationDirectory = file(BIN_DIR)
}

//Сборка джарника
tasks.register("buildProject", Jar) {
    dependsOn compileProject
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Чистка билда
tasks.register("cleanProject", Delete) {
    delete 'build'
}

tasks.register('JUnitTests', Test) {
    useJUnitPlatform()
    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

Map<String, String> getMainAttr() {
    Map<String, String> attr = new HashMap<>()
    attr.put("Main-Class", MAIN_CLASS)
    return attr
}

static Map<String, String> getHashAttributes() {
    Map<String, String> attr = new HashMap<>()
    List<String> projectFiles = listFilesFromDir('src')
    String checkSumMD5 = hashFilesWithAlgorithm("MD5", projectFiles)
    String checkSumSHA1 = hashFilesWithAlgorithm("SHA-1", projectFiles)
    attr.put("MD5", checkSumMD5)
    attr.put("SHA-1", checkSumSHA1)
    return attr
}

static List<String> listFilesFromDir(String dir) {
    List<String> list = new ArrayList<>()
    for (File f : new File(dir).listFiles()) {
        if (f.isDirectory())
            list.addAll(listFilesFromDir(f.toString()))
        else
            list.add(f.toString())
    }
    return list
}

static String hashFilesWithAlgorithm(String algorithm, List<String> files) {
    MessageDigest md = MessageDigest.getInstance(algorithm)
    for (String f : files) {
        md.update(Files.readAllBytes(Paths.get(f)))
    }
    String checkSum = Base64.getEncoder().encodeToString(md.digest())
    return checkSum
}

tasks.register('docc', Jar) {
    dependsOn javadoc
    Map<String, String> mainAttrs = getMainAttr()
    Map<String, String> hashes = getHashAttributes()
    manifest {
        attributes(mainAttrs)
        attributes(hashes, "Hashes")
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    from(JAVADOC_DIR) {
        include 'javadoc/'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Музыкальная сборка джарника
tasks.register("music") {
    dependsOn buildProject
    doLast {
        def musicFile = new File(MUSIC_FILE)
        AudioInputStream audioStream = AudioSystem.getAudioInputStream(musicFile)
        Clip clip = AudioSystem.getClip()
        clip.open(audioStream)
        clip.start()
    }
}

//проверяет валидность всех xml проекта
tasks.register("xml") {
    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        fileTree(dir: 'src', include: '**/*.xml').each { file ->
            try {
                parser.parse(file)
                println "File $file is valid."
            } catch (Exception e) {
                println "File $file is not valid: ${e.message}"
            }
        }
    }
}

tasks.register('native2ascii') {
    doLast {
        ant.native2ascii(
                src: 'src/main/resources',
                includes: '**.properties',
                dest: 'src/main/resources/ASCII')
    }
}

List<String> readFilesResistantForDiff() {
    List<String> files = new ArrayList<>()
    try {
        BufferedReader reader = new BufferedReader(new FileReader(new File(DIFF_FILE)))
        files = reader.readLines()
    } catch (FileNotFoundException e) {
        e.printStackTrace()
    } catch (IOException e) {
        e.printStackTrace()
    }
    return files
}

tasks.register('gitdiff') {
    List<String> filesFromProperties = readFilesResistantForDiff()
    String changedFile = ""
    boolean wrongFileWasModified = false
    def out = new ByteArrayOutputStream()
    for (String file : filesFromProperties) {

        exec {
            commandLine 'git', 'diff', file
            standardOutput = out
        }

        if (out.size() > 0) {
            changedFile = file
            wrongFileWasModified = true
            break
        }
    }
    out.close()

    if (wrongFileWasModified) {
        println("File \"" + changedFile + "\" from properties has been modified")
        println("Commit rejected")
    } else {
        exec {
            commandLine 'git', 'add', '.'
        }
        exec {
            commandLine 'git', 'commit', '-m', '"commit with gitdiff task"'
        }
    }
}

remotes {
    web01 {
        host = 'se.ifmo.ru'
        user = 's336428'
        port = 2222
        password = PASSWORD
    }
}

tasks.register('scp') {
    dependsOn buildProject

    String pathToJar = LIB_DIR + "/" + JAR_NAME

    doLast {
        ssh.run {
            settings {
                pty = true
            }
            session(remotes.web01) {
                put from: file(pathToJar), into: PATH_TO_REMOTE_DIR
            }
        }
    }
}
