import javax.sound.sampled.*
import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Files
import java.nio.file.Paths
import java.security.MessageDigest

plugins {
    id 'java'
    id 'war'
}

group 'com.vuhtang'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

ext {
    junitVersion = '5.9.2'
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

dependencies {
    compileOnly('jakarta.platform:jakarta.jakartaee-api:9.1.0')
    implementation group: 'com.google.code.gson', name: 'gson', version: '2.9.1'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'

    implementation group: 'javax.validation', name: 'validation-api', version: '2.0.1.Final'
    implementation group: 'javax.persistence', name: 'javax.persistence-api', version: '2.2'

    implementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.28'
    implementation group: 'com.google.protobuf', name: 'protobuf-java', version: '3.21.7'
    implementation group: 'org.hibernate', name: 'hibernate-core', version: '5.6.10.Final'

}

test {
    useJUnitPlatform()
}

//Компиляция
tasks.register("compileProject", JavaCompile) {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    classpath = sourceSets.main.compileClasspath
    source = SRC_DIR
    destinationDirectory = file(BIN_DIR)
}

//Сборка джарника
tasks.register("buildProject", Jar) {
    dependsOn compileProject
    manifest {
        attributes 'Main-Class': MAIN_CLASS
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Чистка билда
tasks.register("cleanProject", Delete) {
    delete 'build'
}

tasks.register('JUnitTests', Test) {
    useJUnitPlatform()
    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

Map<String, String> getMainAttr() {
    Map<String, String> attr = new HashMap<>()
    attr.put("Main-Class", MAIN_CLASS)
    return attr
}

static Map<String, String> getHashAttributes() {
    Map<String, String> attr = new HashMap<>()
    List<String> projectFiles = listProjectFilesFromDir('src')
    String checkSumMD5 = hashFilesWithAlgorithm("MD5", projectFiles)
    String checkSumSHA1 = hashFilesWithAlgorithm("SHA-1", projectFiles)
    attr.put("MD5", checkSumMD5)
    attr.put("SHA-1", checkSumSHA1)
    return attr
}

static List<String> listProjectFilesFromDir(String dir) {
    List<String> list = new ArrayList<>()
    for (File f : new File(dir).listFiles()) {
        if (f.isDirectory())
            list.addAll(listProjectFilesFromDir(f.toString()))
        else
            list.add(f.toString())
    }
    return list
}

static String hashFilesWithAlgorithm(String algorithm, List<String> files) {
    MessageDigest md = MessageDigest.getInstance(algorithm)
    for (String f: files) {
        md.update(Files.readAllBytes(Paths.get(f)))
    }
    String checkSum = Base64.getEncoder().encodeToString(md.digest())
    return checkSum
}

tasks.register('docc', Jar) {
    dependsOn javadoc
    Map<String, String> mainAttrs = getMainAttr()
    Map<String, String> hashes = getHashAttributes()
    manifest {
        attributes(mainAttrs)
        attributes(hashes, "Hashes")
    }

    from(BIN_DIR) {
        include '**/*.class'
    }

    from(JAVADOC_DIR) {
        include 'javadoc/'
    }

    archiveFileName = JAR_NAME
    destinationDirectory = file(LIB_DIR)
}

//Музыкальная сборка джарника
tasks.register("music") {
    dependsOn buildProject
    doLast {
        def musicFile = new File("music.wav")
        AudioInputStream audioStream = AudioSystem.getAudioInputStream(musicFile)
        Clip clip = AudioSystem.getClip()
        clip.open(audioStream)
        clip.start()
    }
}

//проверяет валидность всех xml проекта
tasks.register("xml") {
    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        fileTree(dir: 'src', include: '**/*.xml').each { file ->
            try {
                parser.parse(file)
                println "File $file is valid."
            } catch (Exception e) {
                println "File $file is not valid: ${e.message}"
            }
        }
    }
}
